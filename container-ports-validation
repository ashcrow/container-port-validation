#!/usr/bin/env ruby
#
# Created to validate TODO _PUT_BZ_HERE_
#
# This script should not require any ruby libs other than what is in the
# standard library

require 'json'

# The maximum length of container.ports.name
ALLOWED_LENGTH = 14
# The valid structure of container.ports.name
ALLOWED_CHARS = Regexp.new('^[a-z0-9]{1}[a-z0-9\-]*[a-z0-9]{1}[^\-]?$')

# validate verifies that value matches required conventions
#
# Rules of container.ports.name validation:
# * must be less that 15 chars
# * at least one letter
# * only a-z0-9-
# * hyphens can not be leading or trailing or next to eachother
#
# ==== Attributes
#
# * +value+ - Value to validate
#
# ==== Examples
#
# errors = validate("idonoterror")
# errors = validate("-ireturn1error")
# errors = validate("-ireturn2errors")
def validate(value)
    errors = []
    if value.length > ALLOWED_LENGTH
        errors << "Value #{ value } is too long. Max size is #{ ALLOWED_LENGTH }"
    end
    if not ALLOWED_CHARS.match(value)
        errors << "Value #{ value } does not match #{ ALLOWED_CHARS } "
    end
    return errors
end

# list_namespaces lists the namespaces names
#
# ==== Examples
#
# items = list_namespaces
def list_namespaces
    response = %x( oc get namespaces -o template --template='{{range .items}}{{.metadata.name}}{{"\n"}}{{end}}')
    return response.split('\n')
end


# list_items returns a list of items from the api
#
# ==== Attributes
#
# * +kind+ - Kind of item to access
# * +namespace+ - Namespace to look in
# ==== Examples
#
# items = list_items('pods', 'mynamespaces')
def list_items(kind, namespace)
    if namespace.to_s != ''
        response = %x( oc get --namespace=#{ namespace } -o json #{ kind })
    else
        response = %x( oc get -o json #{ kind })
    end
    items = JSON.parse response
    return items["items"]
end

# get_item returns one single item from the api
#
# ==== Attributes
#
# * +kind+ - Kind of item to access
# * +name+ - Name of the item
# * +namespace+ - Namespace to look in
# ==== Examples
#
# item = get_item('rc', 'myrc', 'mynamespace')
def get_item(kind, name, namespace)
    if namespace.to_s != ''
        response = %x( oc get --namespace=#{ namespace } -o json #{ kind } #{ name })
    else
        response = %x( oc get -o json #{ kind } #{ name })
    end
    return JSON.parse response
end

def get(obj, *path)
    o = obj
    for p in path
        if o[p].nil?
            return []
        end
        o = o[p]
    end
    return o
end

# main is the main entry point to this script
def main
    has_oc = system( 'oc whoami' )
    if has_oc != true
        puts 'Can not find oc in the PATH. Exiting...'
        exit
    end
    # Where the magic happens
    list_namespaces().each { |namespace|
        # TODO: Loop over daemonsets and templates too?
        list_items('replicationcontrollers', namespace).each { |rc|
            puts "Checking rc #{rc["metadata"]["name"]}"
            #rc["spec"]["template"]["spec"]["containers"].each { |container|
            get(rc, "spec", "template", "spec", "containers").each {|container|
                #container["ports"].each { |port|
                get(container, "ports").each {|port|
                    puts validate(port["name"])
                }
            }
        }
        list_items('pods', namespace).each { |pod|
            puts "Checking pod #{pod["metadata"]["name"]}"
            #pod["spec"]["containers"].each { |container|
            get(pod, "spec", "containers").each {|container|
                #container["ports"].each { |port|
                get(container, "ports").each {|port|
                    puts validate(port["name"])
                }
            }
        }
        list_items('deploymentconfigs', namespace).each { |dc|
            puts "Checking dc #{dc["metadata"]["name"]}"
            #dc["spec"]["template"]["spec"]["containers"].each { |container|
            get(dc, "spec", "template", "spec", "containers").each {|container|
                #container["ports"].each { |port|
                get(container, "ports").each {|port|
                    puts validate(port["name"])
                }
            }
        }
    }


end

# Execute main function
main
